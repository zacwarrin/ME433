# -*- coding: utf-8 -*-
"""ME433 HW14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WORu_ei8ZwXlAdJmXEPlQTK-GoB73xWq

PART 1
"""

import csv

t = [] # column 0
data1 = [] # column 1

with open('/sigA.csv') as f:
    # open the csv file
    reader = csv.reader(f)
    for row in reader:
        # read the rows 1 one by one
        t.append(float(row[0])) # leftmost column
        data1.append(float(row[1])) # second column

for i in range(len(t)):
    # print the data to verify it was read
    print(str(t[i]) + ", " + str(data1[i]))

"""PART2"""

import matplotlib.pyplot as plt # for plotting
import numpy as np # for sine function

plt.plot(t,data1,'b-*')
plt.xlabel('Time [s]')
plt.ylabel('Signal')
plt.title('Signal vs Time')
plt.show()

"""PART 3"""

sample_rate = len(t)/t[-1]
print(sample_rate)

"""PART 4"""

import matplotlib.pyplot as plt
import numpy as np

def plot_fft(data,t,title):

  sample_rate = len(t)/t[-1]

  Fs = sample_rate # sample rate
  Ts = 1.0/Fs; # sampling interval
  ts = np.arange(0,t[-1],Ts) # time vector
  y = data # the data to make the fft from
  n = len(y) # length of the signal
  k = np.arange(n)
  T = n/Fs
  frq = k/T # two sides frequency range
  frq = frq[range(int(n/2))] # one side frequency range
  Y = np.fft.fft(y)/n # fft computing and normalization
  Y = Y[range(int(n/2))]

  fig, (ax1, ax2) = plt.subplots(2, 1)
  ax1.plot(t,y,'b')
  ax1.set_xlabel('Time')
  ax1.set_ylabel('Amplitude')
  ax1.set_title(title)
  ax2.loglog(frq,abs(Y),'b') # plotting the fft
  ax2.set_xlabel('Freq (Hz)')
  ax2.set_ylabel('|Y(freq)|')
  plt.show()

import csv

t_a = [] # column 0
data_a = [] # column 1

t_b = [] # column 0
data_b = [] # column 1

t_c = [] # column 0
data_c = [] # column 1

t_d = [] # column 0
data_d = [] # column 1

files = ['/sigA.csv','/sigB.csv','/sigC.csv','/sigD.csv']
datas = [data_a,data_b,data_c,data_d]
times = [t_a,t_b,t_c,t_d]
title = ['Set A', 'Set B', 'Set C', 'Set D']

for i in range(4):
  with open(files[i]) as f:
      # open the csv file
      reader = csv.reader(f)
      for row in reader:
          # read the rows 1 one by one
          times[i].append(float(row[0])) # leftmost column
          datas[i].append(float(row[1])) # second column

for j in range(4):
  plot_fft(datas[j],times[j],title[j])

"""PART 5"""

from types import new_class
import csv
import matplotlib.pyplot as plt
import numpy as np

def plot_fft_multiple(data,data_filt,t,title):

  sample_rate = len(t)/t[-1]

  Fs = sample_rate # sample rate
  Ts = 1.0/Fs; # sampling interval
  ts = np.arange(0,t[-1],Ts) # time vector
  y = data # the data to make the fft from
  n = len(y) # length of the signal
  k = np.arange(n)
  T = n/Fs
  frq = k/T # two sides frequency range
  frq = frq[range(int(n/2))] # one side frequency range
  Y = np.fft.fft(y)/n # fft computing and normalization
  Y = Y[range(int(n/2))]

  Fs2 = sample_rate # sample rate
  Ts2 = 1.0/Fs2; # sampling interval
  ts2 = np.arange(0,t[-1],Ts2) # time vector
  y2 = data_filt # the data to make the fft from
  n2 = len(y2) # length of the signal
  k2 = np.arange(n2)
  T2 = n2/Fs2
  frq2 = k2/T2 # two sides frequency range
  #frq2 = frq[range(int(n2/2))] # one side frequency range
  frq2 = frq[:int(n2/2)]
  Y2 = np.fft.fft(y2)/n2 # fft computing and normalization
  Y2 = Y2[range(int(n2/2))]


  fig, (ax1, ax2) = plt.subplots(2, 1)
  ax1.plot(t, y, 'k', label='y')
  ax1.plot(t, y2, 'r', label='y2')
  ax1.set_xlabel('Time')
  ax1.set_ylabel('Amplitude')
  ax1.set_title(title+' X = 40')
  ax2.loglog(frq,abs(Y),'k') # plotting the fft
  ax2.loglog(frq,abs(Y2),'r') # plotting the fft
  ax2.set_xlabel('Freq (Hz)')
  ax2.set_ylabel('|Y(freq)|')
  plt.show()

t_a = [] # column 0
data_a = [] # column 1

t_b = [] # column 0
data_b = [] # column 1

t_c = [] # column 0
data_c = [] # column 1

t_d = [] # column 0
data_d = [] # column 1

files = ['/sigA.csv','/sigB.csv','/sigC.csv','/sigD.csv']
datas = [data_a,data_b,data_c,data_d]
times = [t_a,t_b,t_c,t_d]
title = ['Set A', 'Set B', 'Set C', 'Set D']

for i in range(4):
  with open(files[i]) as f:
      # open the csv file
      reader = csv.reader(f)
      for row in reader:
          # read the rows 1 one by one
          times[i].append(float(row[0])) # leftmost column
          datas[i].append(float(row[1])) # second column

x = 40 # VALUE OF X

new_a = []
new_b = []
new_c = []
new_d = []

new_data = [new_a, new_b, new_c, new_d]

for a in range(4):
  temp = datas[a][0:x-1]
  for b in range(x, len(datas[a])):
    temp.append(datas[a][b])
    new_data[a].append(sum(temp)/len(temp))
    temp.pop(0)
  for z in range(len(times[a])-len(new_data[a])):
    new_data[a].append(0)

for j in range(4):
   plot_fft_multiple(datas[j],new_data[j],times[j],title[j])

"""PART 6"""

from types import new_class
import csv
import matplotlib.pyplot as plt
import numpy as np

def plot_fft_multiple(data,data_filt,t,title):

  sample_rate = len(t)/t[-1]

  Fs = sample_rate # sample rate
  Ts = 1.0/Fs; # sampling interval
  ts = np.arange(0,t[-1],Ts) # time vector
  y = data # the data to make the fft from
  n = len(y) # length of the signal
  k = np.arange(n)
  T = n/Fs
  frq = k/T # two sides frequency range
  frq = frq[range(int(n/2))] # one side frequency range
  Y = np.fft.fft(y)/n # fft computing and normalization
  Y = Y[range(int(n/2))]

  Fs2 = sample_rate # sample rate
  Ts2 = 1.0/Fs2; # sampling interval
  ts2 = np.arange(0,t[-1],Ts2) # time vector
  y2 = data_filt # the data to make the fft from
  n2 = len(y2) # length of the signal
  k2 = np.arange(n2)
  T2 = n2/Fs2
  frq2 = k2/T2 # two sides frequency range
  #frq2 = frq[range(int(n2/2))] # one side frequency range
  frq2 = frq[:int(n2/2)]
  Y2 = np.fft.fft(y2)/n2 # fft computing and normalization
  Y2 = Y2[range(int(n2/2))]


  fig, (ax1, ax2) = plt.subplots(2, 1)
  ax1.plot(t, y, 'k', label='y')
  ax1.plot(t, y2, 'r', label='y2')
  ax1.set_xlabel('Time')
  ax1.set_ylabel('Amplitude')
  ax1.set_title(title+' || A = 0.9, B = 0.1')
  ax2.loglog(frq,abs(Y),'k') # plotting the fft
  ax2.loglog(frq,abs(Y2),'r') # plotting the fft
  ax2.set_xlabel('Freq (Hz)')
  ax2.set_ylabel('|Y(freq)|')
  plt.show()

t_a = [] # column 0
data_a = [] # column 1

t_b = [] # column 0
data_b = [] # column 1

t_c = [] # column 0
data_c = [] # column 1

t_d = [] # column 0
data_d = [] # column 1

files = ['/sigA.csv','/sigB.csv','/sigC.csv','/sigD.csv']
datas = [data_a,data_b,data_c,data_d]
times = [t_a,t_b,t_c,t_d]
title = ['Set A', 'Set B', 'Set C', 'Set D']

for i in range(4):
  with open(files[i]) as f:
      # open the csv file
      reader = csv.reader(f)
      for row in reader:
          # read the rows 1 one by one
          times[i].append(float(row[0])) # leftmost column
          datas[i].append(float(row[1])) # second column

x = 40 # VALUE OF X

new_a = []
new_b = []
new_c = []
new_d = []

new_data = [new_a, new_b, new_c, new_d]

A = 0.9
B = 0.1

for a in range(4):
  average = 0
  for b in range(len(datas[a])):
    average = A*average + B*datas[a][b]
    new_data[a].append(average)

for j in range(4):
   plot_fft_multiple(datas[j],new_data[j],times[j],title[j])

"""PART 7"""

from types import new_class
import csv
import matplotlib.pyplot as plt
import numpy as np

def plot_fft_multiple(data,data_filt,t,title):

  sample_rate = len(t)/t[-1]

  Fs = sample_rate # sample rate
  Ts = 1.0/Fs; # sampling interval
  ts = np.arange(0,t[-1],Ts) # time vector
  y = data # the data to make the fft from
  n = len(y) # length of the signal
  k = np.arange(n)
  T = n/Fs
  frq = k/T # two sides frequency range
  frq = frq[range(int(n/2))] # one side frequency range
  Y = np.fft.fft(y)/n # fft computing and normalization
  Y = Y[range(int(n/2))]

  Fs2 = sample_rate # sample rate
  Ts2 = 1.0/Fs2; # sampling interval
  ts2 = np.arange(0,t[-1],Ts2) # time vector
  y2 = data_filt # the data to make the fft from
  n2 = len(y2) # length of the signal
  k2 = np.arange(n2)
  T2 = n2/Fs2
  frq2 = k2/T2 # two sides frequency range
  #frq2 = frq[range(int(n2/2))] # one side frequency range
  frq2 = frq[:int(n2/2)]
  Y2 = np.fft.fft(y2)/n2 # fft computing and normalization
  Y2 = Y2[range(int(n2/2))]


  fig, (ax1, ax2) = plt.subplots(2, 1)
  ax1.plot(t, y, 'k', label='y')
  ax1.plot(t, y2, 'r', label='y2')
  ax1.set_xlabel('Time')
  ax1.set_ylabel('Amplitude')
  ax1.set_title(title+' || 43 Coeff, Blackman, Cutoff: 10Hz, Bandwidth: 11Hz')
  ax2.loglog(frq,abs(Y),'k') # plotting the fft
  ax2.loglog(frq,abs(Y2),'r') # plotting the fft
  ax2.set_xlabel('Freq (Hz)')
  ax2.set_ylabel('|Y(freq)|')
  plt.show()

t_a = [] # column 0
data_a = [] # column 1

t_b = [] # column 0
data_b = [] # column 1

t_c = [] # column 0
data_c = [] # column 1

t_d = [] # column 0
data_d = [] # column 1

files = ['/sigA.csv','/sigB.csv','/sigC.csv','/sigD.csv']
datas = [data_a,data_b,data_c,data_d]
times = [t_a,t_b,t_c,t_d]
title = ['Set A', 'Set B', 'Set C', 'Set D']

for i in range(4):
  with open(files[i]) as f:
      # open the csv file
      reader = csv.reader(f)
      for row in reader:
          # read the rows 1 one by one
          times[i].append(float(row[0])) # leftmost column
          datas[i].append(float(row[1])) # second column

new_a = []
new_b = []
new_c = []
new_d = []

new_data = [new_a, new_b, new_c, new_d]


h = [
    0.000000000000000000,
    0.000000000000000000,
    -0.000081834214978028,
    -0.000326096238442203,
    -0.000642816996088601,
    -0.000695018548366354,
    0.000000000000000001,
    0.001736847869972494,
    0.004159869148934147,
    0.005968723099462438,
    0.005161230271574798,
    -0.000000000000000003,
    -0.009543105285794258,
    -0.020580885772932728,
    -0.027238087673063266,
    -0.022256603595137682,
    0.000000000000000006,
    0.040324441645839759,
    0.092847944151492640,
    0.145857766042121251,
    0.185335793991518061,
    0.199943664207774402,
    0.185335793991518089,
    0.145857766042121306,
    0.092847944151492667,
    0.040324441645839752,
    0.000000000000000006,
    -0.022256603595137682,
    -0.027238087673063276,
    -0.020580885772932725,
    -0.009543105285794265,
    -0.000000000000000003,
    0.005161230271574798,
    0.005968723099462441,
    0.004159869148934144,
    0.001736847869972498,
    0.000000000000000001,
    -0.000695018548366353,
    -0.000642816996088603,
    -0.000326096238442204,
    -0.000081834214978028,
    0.000000000000000000,
    0.000000000000000000,
]

x = len(h)

for a in range(4):
  temp = datas[a][0:x-1]
  for b in range(x, len(datas[a])):
    temp.append(datas[a][b])
    weighted = 0
    for c in range(x):
      weighted += h[c]*temp[c]
    new_data[a].append(weighted)
    temp.pop(0)
  for z in range(len(times[a])-len(new_data[a])):
    new_data[a].append(0)

for j in range(4):
   plot_fft_multiple(datas[j],new_data[j],times[j],title[j])